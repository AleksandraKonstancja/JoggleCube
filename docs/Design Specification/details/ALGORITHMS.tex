\subsection{Significant algorithms} %Leave this Sam and Nathan
    \subsubsection{Dictionary Load}
    Dictionary loading is an algorithm that is actually fairly short in nature but requires very specific elements to be efficient, to allow for the Dictionary to be built quick enough. This is achieved by utilizing the HashMap data structure in the Java standard library. This is achieved by feeding the given file name into the function and then the algorithm will find the file name given in the resources folders of the project. At this point it will read the entire contents of the file into the HashMap<String, String> data structure, the HashMap uses the key and value as the same String input, the string input is the word that is being added to the dictionary.
    
    This function took some testing to get the design right, it was tested by having the load time being calculated and displayed in the console. The load times on machines that I had tested it on never gets over 600ms to any significant degree (170,000+ words present), so the dictionary loading did not require a load screen before the main menu, so to stop the functional requirement of things happening within 1 second of an action happening being broken.
    
    This particular algorithm should be called in the overall back-end JoggleCube class whilst the algorithm is written in the Dictionary class.
    \subsubsection{Dictionary Search}
    Dictionary search was the part of the program that had to most crucially be performed quickly. If the search was slow it would be noticeable in the game and that leads to the main design decision of loading the dictionary into a HashMap of String key-value pairs where the key and the value are both strings. This algorithm is to be called every time the player submits a word so it was critical that it was fast.
    
    The search should be achieved by entering a word into the method and returning true if the word is in the dictionary HashMap structure, or false if it is not. It requires no further data and the actual search of the HashMap is handled by the Java Standard Library implementation of HashMap.
    
    This algorithm is called in the JoggleCube class when testing the validity of an entered word against known statistics. The actual algorithm is present in the Dictionary Class.
    \subsubsection{Finding neighbouring blocks/Is a neighbour}
    Finding which blocks are neighbouring other blocks was surprisingly hard to calculate at least initially. The original design was meant to take each block and decide whether or not it is a neighbour iterating through all other potential blocks. The runtime for this was much higher than the design we finally settled on after giving it more thought. The algorithm we settled on would calculate the potential neighbours of a block by generating each of the potential 27, neighbours I check to see if they are valid block numbers and if they are then they are returned as a neighbour of that block.
    
    The function was originally designed to be a backend feature feeding an ArrayList of coordinates, however, it is adapted into a front-end version to help with the grid displayer.
    
    The algorithm was originally meant to work in the Cube class and the adapted version was written in the front-end version. The actual algorithm was implemented in the Grid Displaying class.
    \subsubsection{Saving Grids} \label{SaveGrid}
    The act of saving the grid requires a filename to be given as a string into the algorithm which will take the current cube, current language and current cube high scores and save it in the appropriate grid format, this is discussed in Section: \ref{CubePersistance}. Then after creating the file, it prints out the language of the current state of the cube/game. Then it feeds the file into the saveCube method which handles it saving in the right order and format previously discussed, then it feeds the same file pointer into the saveScores method of HighScores which is discussed also in Section: \ref{Scores}. After that, it closes the file and thus the file is saved.
    
    The function handles the saving of a grid in it's current state to the saves folder made at program startup if not already present in the documents folder of the current machine user.
    
    This algorithm is called whenever the user asks to save the grid, on the front-end, however, the algorithm itself is present in JoggleCube the main backend class.
    \subsubsection{Loading Grids} \label{LoadGrid}
    To load a grid much like saving a grid it requires a filename to be given as a string into the algorithm. Then the file is opened by the program and the data is read in respectively in a way similar to how it was saved. It reads in the language of the file and then sets the current language to that in the settings. Then the file is feed into loadCube in the cube class which causes the cube data to be loaded in, then that same file is given to the loadScores in Scores class. The way the cube and high scores for that cube are loaded is relevant to the way they should be saved and thus can be found in Sections: \ref{CubePersistance} and \ref{Scores}. At this point, the saved state of the game has replaced all relevant parts of the program so that the new Cube has been fully loaded.
    
    The function handles loading of a new cube/grid, the high scores and the language of the saved data.
    
    This algorithm is called on the front-end, but the actual algorithm is only present in the JoggleCube main back-end class.
    \subsubsection{Random Letter Generation}\label{RandomLetter}
    Random Letter Generation is accomplished by utilising a 'Bag of Letters'. The Letters are stored in an ArrayList<String>. So the algorithm loads in the 'Bag of letters' from a file containing the number of letters correlating to the abundance of the letters given in the functional requirements or if it's not English we will base it from the basic scrabble rules of that language. Then it generates a random number using this random number it takes the letter from the array list and removes it from the list, at that point it is put into the cube at the first position [0][0][0] and then it iterates by one on the first to put another random letter in to [0][0][1] and so on until it iterates up to two on each part of the modelled cube, until 27 unique positions in the array have been used and pseudo-randomly generates the cube.
    
    The function in question will populate the entire cube with random letters in Block objects utilising the random function built into Java the cube should be entirely random, using the weightings given in the functional requirements. This is a backend function which is used to create the cube.
    
    The algorithm should be called in the JoggleCube class where the cube is present to regenerate the cube into a new random cube as well as once at startup. However, the actual algorithm is present in the Cube class.
    \subsubsection{Creation of JoggleCube in documents folder}
    The JoggleCube program requires a place to saved files locally that isn't in the game files itself, it needs this as we want to package the program into a .jar Java file so we can give it out to be people to test the game for us and so we can easily test it on different machines. Therefore the design decision was taken to store saves and the overall scores for high scores locally on the machine in the documents folder, regardless of the operating system used. This can be achieved by finding the local system home and navigating to the documents folder. If in the documents folder the JoggleCube folder has already been created then do nothing. If it hasn't we want it to create the JoggleCube folder, the saves folder inside of that folder and a high score folder for housing the saves and overall high scores for this user account respectively. Then we want to create the overAll.highscores file and copy three example grid saves into the saves folder.
    
    The function in question will make sure that the files are present for the program when it needs them as well as making sure that the saves can be saved locally, also saving the high scores locally. This stops potential errors when looking for these files, later in the program.
    
    The algorithm should be called in JoggleCube when the JoggleCube object is created and this is a private method to stop it being called outside of this class.
    \subsubsection{Recent Grids}
    The recent grids algorithm should check the documents on the computer for the saves that were saved locally, and return an ObservableList<String> of the names of these files without the .grid extension. It should accomplish this by getting a list of all files in the saves folder in an array of File[]. Then we add the names of the files to an ArrayList<String> to store the full name of the file including the file extension, .grid. Then using this ArrayList we will process each part of the list individually using a StringBuilder to remove the .grid file extension and add it to a new ObservableList<String> so we can return it. We didn't originally put things in the ObservableList as it is harder to process data in this list than an ArrayList. Then return this new ObservableList so it can be displayed on the front-end class that called it.
    
    This function will make it easy for people to load any grid they have saved, as all saved grids will be displayed in this list.
    
    The algorithm should be called on the front-end, and the actual algorithm should be present in the JoggleCube class on the back-end of the program.
    
    \subsubsection{Displaying the Grids} %Nathan
    The grid displaying is going to be done using two classes: CubeFx and BlockFx. Where BlockFX will store a label, two blocks and 4 materials for each possible state of the Block, the block will then have 4 possible states in which it can be. CubeFx will take a 3-dimensional cube of letters and generate its own internal 3-dimensional cube of BlockFX's for display. The CubeFx class will also handle exploding the 3d cube using java's timeline library to animate it.
    
    \subsubsection{Loading overall High Scores}
    The way we load overall highscores is very similar in some aspects to how we load a grid just there isn't a grid to be loading. The overall highscores loads in the data by calling loadScores in the Scores class by finding the overall highscores in the previously made folder in the documents folder, the file itself should be called overAll.highscores. The returned ArrayList from the loadScores method should then be set as the overHighscores instance variable in JoggleCube so it can be used in other methods down the line.
    
    This function should be called on program startup. The algorithm should be present in the JoggleCube class and should be called at either the constructor of JoggleCube or during Main.
    
    \subsubsection{Word Score Generation}\label{WordScore}
    Word Score Generation is accomplished by feeding in a word as a String, into the method. then we will analyse the word letter by letter utilising the scores HashMap that was created when the grid was loaded with the "Bag of Letters" was loaded. The scores HashMap is a key-value pair data structure that utilizes the letter as the Key and the score associated with that letter as the value. Using this previously constructed data structure, we can search for the value of the letter at each point of the word, by searching the HashMap. At first, we check whether the letter and the letter following it make up a double letter in the HashMap, if they do we increment the search loop by 1 to emulate that extra letter and then we add the score of that pair to the int variable that is used to handle the total score. If the letter is not part of a pair, it then checks if that letter is a valid letter by itself and if it is, it then will add the score of that letter to the overall sum. If neither of these checks works then there is an error in the scores loaded from the file and an error should be handled. At this point, we then return the value squared, as the scores that are saved/loaded are the given values for the letters of scrabble.
    
    The function in question will return the score as an int to the place that called it. This is another backend function which is used to update the backend values of the score and display the new score on the front-end GUI display.
    
    The algorithm should be called in the JoggleCube class the main backend class that handles most of the algorithm decisions. The actual algorithm is also present in JoggleCube and thus it can be handled as a private method as it isn't needed to be called in other classes. However, if we decided to add in extra features such as word score display for the word during the game the function could be made public and called.
    \subsubsection{Test Word Validity}
    Test Word Validity is accomplished by first of all checking whether the word has already been checked and successfully added to the list of previously used words, this list of previously used words is added to when this function is about to return true, so if the word has already been checked and it returned true then the function would return false, as this word is not valid. The next check that occurs is actually checking whether it is a valid word in the dictionary of the language that is currently being used (Default is American English (There was no easy to access a large dictionary of British English Scrabble legal words that we could find)). If it is a word that has appeared in the dictionary then the current score of the game is updated using word score generation, the game score label is updated on the front end and the word that is checked against is added to the aforementioned stored words list. Then the function should return true, else if it is not in the loaded dictionary it returns false.
    
    The function in question will take in the String word and return true if the word is valid and update the relevant data sets or it will return false if it is not valid and update nothing.
    
    The algorithm should be called from the front-end class that is handling the processing of words entered when the submit button is pressed. However, the actual algorithm is present in the main JoggleCube back-end class.